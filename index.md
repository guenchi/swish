### 文件内容翻译

#### 第1页

**Swish并发引擎**

版本 2.8.1

编辑：Bob Burger

© 2018-2024 Beckman Coulter, Inc. 根据MIT许可证授权。

#### 第2页

**目录**

* 1 Swish简介  
  * 1.1 概述  
  * 1.2 监督树

* 2 使用Swish开发软件  
  * 2.1 简介  
  * 2.2 部署类型  
    * 2.2.1 脚本  
    * 2.2.2 链接程序  
    * 2.2.3 独立程序  
    * 2.2.4 服务  
  * 2.3 运行测试  
  * 2.4 编程接口  
    * 2.4.1 配置  
    * 2.4.2 程序生命周期  
    * 2.4.3 外部接口  
    * 2.4.4 测试

* 3 操作系统接口  
  * 3.1 简介  
  * 3.2 操作理论  
  * 3.3 编程接口  
    * 3.3.1 C接口  
    * 3.3.2 系统函数和过程  
    * 3.3.3 端口函数
    * 3.3.4 进程函数

* 3.3.5 文件系统函数  30 

* 3.3.6 TCP/IP函数  33 

* 3.3.7 SQLite函数  35 

* 3.3.8 消息摘要函数  38 

## 4 Erlang嵌入


4.1 简介 & 39 \\

4.2 数据结构 & 39 \\

4.3 操作理论 & 41 \\

4.4 编程接口 & 43 \\

4.4.1 进程创建 & 43 \\

4.4.2 进程注册 & 43 \\

4.4.3 进程终止、链接和监控 & 44 \\

4.4.4 消息和模式匹配 & 47 \\

4.4.5 进程属性 & 50 \\

4.4.6 其他 & 51 \\

4.4.7 元组 & 57 \\

4.4.8 I/O & 59 \\

4.4.9 队列 & 71 \\

4.4.10 哈希表 & 71 \\

4.4.11 错误字符串 & 72 \\

4.4.12 字符串工具 & 73 \\

4.4.13 消息摘要 & 75 \\

4.4.14 数据编码工具 & 77 \\

4.4.15 宏工具 & 78 \\ \end{tabular}

## 5 正则表达式

\begin{tabular}{l l}  & **80** \\

5.1 简介 & 80 \\

5.2 编程接口 & 81 \\

5.3 正则表达式模式语言 & 82 \\

5.3.1 基本断言 & 82 \\

5.3.2 字符和字符类 & 83 \\ \end{tabular}

#### 第4页

.

#### 第5页 [文本层]

10.3 编程接口 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
11 数据库接口
116
11.1 简介 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
11.2 操作理论 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 116
11.3 设计决策 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
11.4 编程接口 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
12 日志数据库
128
12.1 简介 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
12.2 操作理论 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
12.2.1 初始化
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 128
12.2.2 扩展
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
12.3 编程接口 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 129
12.4 发布的事件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 133
13 系统统计
134
13.1 简介 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
13.2 操作理论 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
13.3 编程接口 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 134
13.4 发布的事件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
14 HTTP接口
136
14.1 简介 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
14.2 操作理论 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
14.2.1 URL处理程序和媒体类型处理程序 . . . . . . . . . . . . . . . . . . . . . . 137
14.2.2 默认文件处理 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
14.2.3 动态页面 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
14.2.4 WebSocket协议 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 138
14.3 安全性 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
14.4 编程接口 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 139
14.4.1 动态页面构造 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
14.4.2 WebSocket协议 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
14.4.3 超文本标记语言 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 146
5

#### 第6页 [文本层]

14.4.4 JavaScript对象表示法 . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
14.5 发布的事件 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
15 命令行接口
153
15.1 简介 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
15.2 操作理论 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 153
15.3 编程接口 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
16 并行
159
16.1 简介 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
16.2 操作理论 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
16.3 编程接口 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 160
参考文献
162
图列表
164
索引
165
6

#### 第7页

## 第1章 Swish简介

### 1.1 概述

Swish并发引擎是一个用于编写具有消息传递并发性的容错程序的框架。它使用Chez Scheme [6]编程语言，并嵌入了Erlang [8]编程语言的概念。Swish还提供了一个遵循HTTP协议 [14]的Web服务器。

Swish使用消息传递并发性和故障隔离来提供容错软件 [1, 18]。软件被划分为轻量级进程，这些进程通过异步消息传递进行通信，但在其他方面彼此隔离。由于进程不共享可变状态，一个进程不能破坏另一个进程的状态——这是使用共享状态并发的软件中常见的问题。

当软件检测到错误且无法继续正常处理时，会引发异常。如果异常未被引发它的进程捕获，则该进程将被终止。错误记录器会记录进程崩溃和其他软件错误。

有两种机制可以检测进程终止，即**链接**和**监控**。进程可以相互链接，以便当一个进程异常退出时，其他进程会被杀死。一个进程可以监控其他进程，并接收包含终止原因的进程关闭消息。

单个事件分发器接收来自各个进程的事件，并将它们发送给所有附加的事件处理程序。事件处理程序根据其需求过滤事件。

Swish使用Chez Scheme编写，主要有两个原因。首先，它提供了高效的一等延续 [4, 20]，这些延续是实现轻量级进程所必需的，其内存和CPU开销比操作系统线程少得多。其次，Chez Scheme提供了强大的语法抽象能力 [7]，这些能力使得代码能够紧密反映设计的各个方面。例如，消息传递系统使用语法抽象来简洁地指定模式匹配。

I/O操作通过C代码异步执行（见第3章），并通过Scheme回调函数完成。使用异步I/O是为了让Swish可以在单线程中运行，而不会因I/O阻塞。异步操作的结果由Scheme代码同步调用，从而控制重入。

#### 第8页

### 监督树

调用`app:start`会生成一组进程，这些进程组织在一个监督树中。默认情况下，Swish使用图1.1所示的监督树。应用程序（见第10章）是一个单一的gen-server，它管理程序的整个生命周期。它链接顶级监督者，并在请求时或在链接的进程死亡时关闭程序。顶级监督者`main-sup`配置为“一损俱损”且不重启，因此其任何子进程的失败都会导致程序崩溃。`event-mgr`工作进程是事件管理gen-server（见第7章）。`log-db`工作进程是一个数据库gen-server（见第12章），它将所有事件记录到日志数据库中。`event-mgr-sentry`工作进程用于在关闭期间确保事件管理器在`log-db`关闭之前停止向其发送事件。`statistics`工作进程是一个系统统计gen-server（见第13章），它定期发布一个`<statistics>`事件。`gatekeeper`工作进程是第8章中描述的gen-server。

可以通过在调用`app:start`之前调用`http:add-file-server`或`http:add-server`（见第14章）将Web服务器添加到监督树中。

图1.1：监督树

#### 第9页

## 第2章 使用Swish开发软件

### 2.1 简介

Swish可用于构建、测试和部署从小型脚本到大型独立应用程序的程序。本章描述了Swish为这些目的提供的一些工具和机制。

### 2.2 部署类型

对于交互式开发，Swish提供了一个REPL，它读取、评估并打印在提示符下输入的程序的值。在REPL中，可以使用`load`过程来评估包含源代码或目标代码的文件内容。这在开发较大程序时非常方便。

Swish提供了几种部署程序的选项。本节描述了这些选项及其权衡。

#### 脚本

一个简单的部署选项是将源代码放在一个以`#!`开头的文件中，该行指定了可以评估脚本的可执行文件的绝对路径。这可以是Swish可执行文件的绝对路径。更常见的是使用`/usr/bin/env`通过程序搜索路径来定位Swish可执行文件。例如，我们可能有：

```bash
$ cat hello

#!/usr/bin/env swish

(printf "Hello, World!\n")

$ chmod +x hello

$ ./hello

Hello, World!
```

在前面的例子中，运行`./hello`会调用Swish可执行文件，并将`./hello`作为其唯一的命令行参数。在启动时，Swish调用`swish-start`来处理其命令行参数。由于第一个参数不是选项（如`-h`、`--help`等），`swish-start`会运行该文件，并将剩余的参数（如果有）作为其命令行参数。例如，以下Echo脚本处理传递给脚本的参数。

```bash
$ cat Echo #!/usr/bin/env swish (printf "-{~:<~a~>~}\n" (command-line-arguments)) $ chmod +x Echo $ ./Echo some camel case identifiers are hard to read SomeCamelCaseIdentifiersAreHardToRead
```

要在脚本文件名之前向Swish可执行文件提供参数，请将`-S`选项添加到`env`中，并在`swish`后添加所需的参数。这里的`-q`选项抑制启动消息并将提示符设置为空字符串，`--`选项告诉Swish在加载脚本后启动REPL。

```bash
$ cat howdy #!/usr/bin/env -S swish -q -- (printf "Howdy, Folks!\n") (printf "prompt: ~s\n" (waiter-prompt-string)) (printf "command-line: ~s\n" (command-line-arguments)) $ chmod +x howdy $ ./howdy Howdy, Folks! prompt: "' command-line: ("-q" "--" "./howdy") (waiter-prompt-string "yes?") yes? (+ 2 3) 5 yes? (exit)
```

### 限制

在部署Swish脚本时，有几个约束需要考虑。

* 自然，Swish必须已安装。要像前面的例子那样使用`/usr/bin/env`，`PATH`环境变量必须包含Swish可执行文件所在的目录。这比在脚本中硬编码Swish可执行文件的绝对路径更可取。

* Chez Scheme也必须安装。特别是，必须安装用于构建Swish的Chez Scheme版本。Swish必须能够定位Chez Scheme引导文件`petite.boot`和`scheme.boot`。如果Chez Scheme安装在非标准位置，可能需要设置`SCHEME_HEAPDIRS`环境变量以帮助Swish定位引导文件。要查看Swish查找引导文件的位置，请运行`swish --verbose`。

#### 第11页

* 本节中显示的`#!`脚本在Windows下无法运行。在MinGW/MSYS中，除非通过将`MSYS_NO_PATHCONV`环境变量设置为1来禁用Posix路径转换，否则这些脚本可能会工作。在Cygwin中，如果包含脚本的目录挂载为其Windows对应目录（例如`C:/Users`和`/Users`），则这些脚本可能会工作。要使这些选项工作，Swish必须能够通过标准搜索顺序定位适当的Chez Scheme DLL。如果当前驱动器不是包含脚本的驱动器，脚本将失败。

#### 2.2.2 链接程序

链接程序是一个以`#!/usr/bin/env swish`开头的Scheme目标文件。Swish运行这些程序的方式与运行脚本的方式相同，只是`swish-start`在运行文件时跳过编译步骤。

我们可以使用`swish-build`从源文件`foo.ss`构建链接程序`foo`，如下所示：

```
